---
layout: post
title: 子视图超出父视图响应事件的方法
description: 项目中的问题解决
image: assets/images/pic04.jpg
---

留坑，明早更新。

## 问题出现：

 我在地图大头针的时候发现，自定义大头针的callout视图实际上是在父视图annotationView的范围外面的，这就导致了，这个callout接收不到点击事件，我在上面加的导航按钮也就无法起作用，于是我想出了下面的解决方法。

***

~~~   
    - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
      UIView *view = [super hitTest:point withEvent:event];
      if (view == nil) {
        for (UIView *subView in self.infoView.subviews) {     
            CGPoint tp = [subView convertPoint:point fromView:self];
            if (CGRectContainsPoint(subView.bounds, tp)) {  
                if ([subView isKindOfClass:[UIButton class]]) {
                     view = subView;
                  }    
              }
          }
      }
     return view;
    }

~~~

***

至此问题完美解决，该方法返回包含指定点的视图层次结构（包括其本身）中的最底层的子视图。该视图用来响应点击事件，所以，当子视图超出边界的时候事实上返回的是nil。当点击事件发生时，我把点击的点转换成成我所需要的响应事件视图的坐标点，然后过滤看是否该点击在该子视图的范围内。如果在的话，就返回该子视图，响应点击。

***

### 简而言之:

1.事件的传递 : 由UIApplication --> UIWindow --> 递归找到最合适的响应者

2.事件的响应 : 调用最合适的响应者的touches方法--> 如果其没有实现,默认做法,将事件传递给上一个响应者-->找到上一个响应者,调用它的touches方法

***

[点击查看hitTest详解](http://blog.csdn.net/jiajiayouba/article/details/23447145)

[点击查看响应者链详解](http://sindrilin.com/ios-dev/2015/12/27/事件传递响应链.html)

